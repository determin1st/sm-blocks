## 2020-09-8/12
- в следствии того что дополнение заняло часть времени разработки,
  оставшиеся, а также новые выявленные пункты:
  - составной запрос фильтрации (запрос определения границ сделан,
    однако он не должен выполнятся одновременно с фильтром, так-как
    фильтр накладывает конкретное ограничение на диапазон цен).
  - ввод в фильтр (различные варианты ниже)
  - обработка ввода, передача нового запроса и презагрузка каталога
    (взаимодействие блока фильтра с основным блоком)

- таким образом 2 основные задачи:
  - доработка фильтра по цене
  - рефакторинг фильтра категорий

- корректировки по вводу:
  - нажатие Enter в первом текстовом поле (минимум) переводит фокус
    во второе поле (максимум), а нажатие Enter на последнем поле
    приводит к мгновенной перезагрузке каталога с учетом новых данных.
  - необходимо выбрать небольшой timeout если пользователь ввел
    данные но не подтвердил их, а например, перевел фокус на другой
    элемент интерфейса, т.е. контрол потерял фокус но пользователь забыл
    подтвердить изменение. либо нужно сделать сброс на предыдущие значения,
    вариант определится при тестировании (полагаю).

#### взаимодействие фильтра
- ввод в фильтр цены не сбрасывает ввод в фильтре категорий, однако
  ввод в фильтр категорий может сбрасывать ввод в фильтр цены,
  это опционально для фильтра категорий и по-умолчанию включено.
- ввод в фильр цены сбрасывает ввод в пагинатор
- вводом считается ввод отличного от предыдущего,
  действительного (в рамках min/max) диапазона цены,
  в противном случае устанавливается предыдущий диапазон

#### дополнение, фильтр категорий

- после рефакторинга
- дополнительная опция filterMode:
  - (0) дерево с чекобксами, можно выбрать несколько
    вариантов (это то что реализовано сейчас).
    при вводе фильтр цены НЕ СБРАСЫВАЕТСЯ.
  - (1) список с пунктами, можно выбрать только один пункт
    из варинтов узла дерева категорий.
    при вводе фильтр цены СБРАСЫВАЕТСЯ.


## 2020-09-1/5
### фильтр товаров по цене
#### бэкэнд
- цена является общим атрибутом для товаров,
  поэтому необходимо выполнять дополнительный SQL запрос при каждом изменении
  в параметрах выборки для определения границ диапазона. т.е. минимальная цена
  товара (A) в текущей выборке и максимальная (B).

- дополнительный запрос отрабатывает не только при изменении числа товаров, а
  и при любых изменениях в параметрах так как может быть одно и то же число
  товаров в разных категориях.

- для облегчения составного запроса, фронтенд должен передавать параметр наличия
  блока с фильтром по цене. если блок отсутствует, что маловероятно, SQL запрос
  будет выполнятся быстрее.

- опции для блока:
  - отключить определение максимальных границ цены (true по-умолчанию, чтобы пока
    не заморачиватся с реализацией дополнительного запроса)
  - отображать дополнительный интерфейс с группами (false, на будущее разбивка
    цены по кликабельным группам, т.е. |12|2|834|33| в срезе количества товаров)
  - дополнительная кнопка для подтверждения ввода (0 по-умолчанию)
    - (0) не отображается
    - (1) отображается обычной + отменяет подтверждение потерей фокуса
    - (2) отображается всплывающей + отменяет подтверждение потерей фокуса
  - основной интерфейс:
    - (0) два текстовых поля с разделителем (по-умолчанию)
    - (1) слайдер с двумя ползунками (определение границ включено)
    - (2) кликабельные группы цен (определение границ включено,
          без среза по кол-ву товаров)

- шаблон блока:
  - аналогичная структура, как у остальных
  - svg изображение для разделителя [-] текстовых полей

#### фронтэнд
- аналогичная структура блока (JS/CSS)
- блок уровня 2: он блокирует остальные блоки напрямую зависящие от
  общего количества записей в результате (пагинатор), а также
  фильтр по категориям, так как оба влияют на выборку (на одном уровне)
- тип интерфейса определяется при создании блока:
  - (0) текстовое поле [min], разделитель [-], текстовое поле [max]
  - ...
- блок растягивается на всю доступную ширину по-умолчанию. высота задается
  стандартной переменной --height, также как и у других горизонтальных
  блоков, для того чтобы можно было уменьшать неско блоков в строке
  пропорционально (потом).
- состояние блока locked: контролы заблокированы для ввода,
  значения сброшены и не отбражаются.
- при разблокировке установить значения и класс.
- при инициализации установить параметр необходимости доп.выборки
  минимального-максимального и среза по количеству товаров.
- при вводе (0):
  - при фокусе выделяется текущее значение в контроле (либо стандартное min/max).
  - можно вводить только целые, положительные числа.
  - завершением ввода считать нажатие Enter или потерб фокуса контролом.
  - при завершении ввода переключается стиль контрола - "значение установлено".
  - полным завершением ввода считать нажатие Enter или потерю фокуса обоими контроламию.
  - при полном завершении, значения переставляются если min>max, распространяются
    на все остальные блоки с фильтром по цене и инициируется перезагрузка каталога.
  - колесико мышки, а также стрелки вверх/вниз (прокручивают) значения
    в текущем контроле от min до max

#### дополнение (вложенная секция)
- необходимо дополнить блок опцией наличия секции. секция может содержать заголовок,
  например "Цена" и возможность скрывать/раскрывать содержимое. содержимым секции,
  если данная опция задана, является интерфейс фильтра.
- для того чтобы не повторять код для последующих блоков нужно адаптировать
  текущий код вложенных секций из фильтра категорий. создать отдельный объект
  MainSection во фронтенде и процедуру-генератор разметки в бэкэнде. подробно:
  - выделить стили из фильтра категорий в отдельный блок `.sm-blocks main-section`
  - выделить код из фильтра категорий в отдельный объект `MainSection`
  - выделить код из генератора разметки в отдельную процедуру `renderSection`
- отложить рефакторинг фильтра категорий
  


## 2020-08-24/30
#### изменения в алгоритме загрузчика (1)=>(2)=>(3), было (1)=>(3)

(1) парсинг скриптов/стилей браузером, запрос конфигурации и запрос
    содержимого корзины (объеденить в один запрос для сокращения общего времени загрузки).
    блоки в это вермя отображаются как заглушки, либо не отображаются/скрыты.
    почему? потому что некоторые блоки (пагинатор, список товаров) отображаются
    некорректно/криво без предварительного вычисления их размеров зависящих от
    различных настроек (напр. число элементов в таблице, кол-во кноп в пагинаторе)
    можно сделать их скрытыми, а можно отображать красивую или не очень заглушку,
    ранее было скрыто до полной загрузки (3).

(2) (a) создание блоков и определение их размеров (если требуется)
    (b) отображаем блоки частично, они неактивны т.е. пользователь не может
        взаимодействовать с ними.
    (c) ожидаем загрузку конфигурации и выполняем инициализацию блоков (один раз),
        инициализация заключается в подготовке данных (например, для блока сортировки
        нужно составить список возможных вариантов сортировки из конфигурации)
    (d) запуск первоначальной загрузки данных в каталог

(3) загрузка в каталог завершена, обновляем и активируем деактивированные блоки.
    ожидание действий пользователя.

(4) действие совершено - блокировка/деактивация блоков (только тех которые нужно)
    и выполнение нового запроса на сервер с обновленными данными.

(5) переход к (3).


#### HTML/CSS (реструктуризация шаблонов и стилей)

- ввести общий класс для всех блоков чтобы не повторять одни и те же стили
  для всех элементов управления внутри блока, а также какие-то общие состояния

- общие классы состояний для соостветствия стадиям (1)=>(2)=>(3) загрузчика:
  (1) div   > div   (пустышка/скрыт, неактивен)
  (2) div.v > div   (неактивен)
  (3) div.v > div.v (активен)

- единая начальная структура блоков: div > div и пустышка-placeholder рядом
```
  <div class="sm-blocks {{названиеБлока}} {{дополнительныйКласс}}">
    <div>{{содержимое}}</div>
    <svg>{{пустышкаЗаглушка}}</svg>
  </div>
```


#### JS (примерные переделки внутри скрипта)

- пройтись по обработчикам событий внутри каждого блока:
    init: оставить только подготовку данных (один раз)(2), остальное убрать,
          ранее также вешались события, считались размеры и обновлялся блок
  change: произошло изменеие (пользователь что-то выбрал)(нет изменений)
    lock: блокировка (нет изменений)
  unlock: разблокировка - удалить, объеденить с load
    load: данные загружены, нужно разблокировать и обновить блок

- все конструкторы блоков должны вешать события сразу

- конструкторы блоков (пагинатор, каталог) должны вызывать фунуции для 
  определения размеров сразу после создания блока (в конце конструктора).

- основной блок (каталог/список товаров):
  - объеденить запрос конфигурации и запрос содержимого корзины
  - ...

- блок фильтра категорий:
  - ...



